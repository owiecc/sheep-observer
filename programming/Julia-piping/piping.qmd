---
title: Piping
lang: en
author: "Szymon BÄ™czkowski"
date: "2023-12-11"
categories: [Julia,functional programming]
description: "Piping is cool, m'kay?"
jupyter: julia-1.9
---

How to structure code. Data flow. Transformations. 

[Advent of code](https://adventofcode.com) is a quaint site that posts one programming problem a day just before Christmas. Just so we can flex our programming muscle. More importanetly, so we can eavsdrop on other people's code. 

## The problem

Advent of code [day one problem](https://adventofcode.com/2023/day/1). It bois down to: given a string, extract first and last digit in each line; join the two digits to form a two-digit number and add all resulting numbers. 

```{julia}
#| output: false
calibration = """
1abc2
pqr3stu8vwx
a1b2c3d4e5f
treb7uchet
"""
```

## Splitting ~~hair~~ lines

Text manipulation is a basic problem in programming. Almost every programming language will have built-in primitives for handling this task. 

Julia's function `eachline` can be conveninently used to break a string into individual lines. However, if we pass our `calibration` variable into `eachline` we will get an error. Fortunately, the [docs](https://docs.julialang.org/en/v1/base/io-network/#Base.eachline) help us out: 

> To iterate over each line of a String, eachline(IOBuffer(str)) can be used.

```{julia}
for cal_line in eachline(IOBuffer(calibration))
    @show cal_line
end
```

Now that we know we can easily split the `calibration` string into individual lines we "only" need to extract the two-digit numbers from them. Adding them is easy. 

## The actual problem

Looking within individual line, our problem can now be states as: given a string, extract first and last digit; join the two digits to form a two-digit number. 

Let's take one of the lines above and use it as a test case. 

```{julia}
#| output: false
cal_line = "a1b2c3d4e5f"
```

First a solution that is quite typical for students after their first MATLAB course. 

```{julia}
number = ""
@show number

for i in 1:length(cal_line)
    s = cal_line[i]
    if isdigit(s)
        number = number * s
        break
    end
end

@show number

for i in length(cal_line):-1:1
    s = cal_line[i]
    if isdigit(s)
        number = number * s
        break
    end
end

@show number

cal_value = parse(Int, number)
```

It works but is also suuuuper long. If you use e.g. VSCode, some of the code will be underlined with a squigly line. It is Julia's linter telling us that:

> Indexing with indices obtained from `length`, `size` etc is discouraged. Use `eachindex` or `axes` instead.

A linter is a tool that continously checks your code for possible errors and [anti-patterns](https://en.wikipedia.org/wiki/Anti-pattern). In this case it is pointing out that `for i in 1:length(cal_line)` is not cool. Let's try to include the proposed fix. 

Instead of creating a vector of indexes `1:length(cal_line)` we can just ask for it: `eachindex(cal_line)` and for the second case: `Iterators.reverse(eachindex(cal_line))`. This is advisable because arrays in Julia can have arbitrary indexes. Forget about the war between [0-based](https://en.wikipedia.org/wiki/Zero-based_numbering) and 1-based indexing in programming. Embrace [Star Wars movies order indexing](https://github.com/giordano/StarWarsArrays.jl). 

Notice that we did not use the `i` variable for anything other than indexing an element of the input string. We should take advante of the fact that we can just iterate over anything that is iterable. Any `String` or `Array` or similar data structure is. If a data structure can be described similar to: _a string is a collection of characters_ or _an array is a collection of numbers_ then it most likely is iterable. 

```{julia}
number = ""
@show number

for s in cal_line
    if isdigit(s)
        number = number * s
        break
    end
end

@show number

for s in reverse(cal_line)
    if isdigit(s)
        number = number * s
        break
    end
end

@show number

parse(Int, number)
```

The code is now a bit prettier but it still looks repetitive and quite verbose. The first loop looks for the first numeric character; the second loop looks for the last numeric character. Conceptually they do almost the same job. 

```{julia}


```

```{mermaid}
flowchart LR
  input[(line)]:::data --> Filter(filter numbers)
  Filter --> First[Get first number] & Last[Get last number] --> Sum[sum] --> Result
  classDef data fill:#f96
```

## Takeaways

### Look for patterns in the problem

Someone has done the boilerplate code for you
Map filter reduce

### Break the problem into smaller problems

Smaller problem = less things to keep in your head at a time
TDD
Parallel work
Modularity