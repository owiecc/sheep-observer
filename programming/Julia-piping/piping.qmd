---
title: Piping
lang: en
author: "Szymon Bęczkowski"
date: "2023-12-11"
categories: [Julia,functional programming]
description: "Piping is cool, m'kay?"
jupyter: julia-1.9
---

How to structure code. Data flow. Transformations. 

[Advent of code](https://adventofcode.com) is a quaint site that posts one programming problem a day just before Christmas. Just so we can flex our programming muscle. More importanetly, so we can eavsdrop on other people's code. 

## The problem

Advent of code [day one problem](https://adventofcode.com/2023/day/1). It bois down to: given a string, extract first and last digit in each line; join the two digits to form a two-digit number and add all resulting numbers. 

```{julia}
#| output: false
calibration = """
1abc2
pqr3stu8vwx
a1b2c3d4e5f
treb7uchet
"""
```

## Interlude I: splitting ~~hair~~ lines

Text manipulation is a basic problem in programming. Almost every programming language will have built-in primitives for handling this task. 

Julia's function `eachline` can be conveninently used to break a string into individual lines. However, if we pass our `calibration` variable into `eachline` we will get an error. Fortunately, the [docs](https://docs.julialang.org/en/v1/base/io-network/#Base.eachline) help us out: 

> To iterate over each line of a String, eachline(IOBuffer(str)) can be used.

```{julia}
for cal_line in eachline(IOBuffer(calibration))
    @show cal_line
end
```

Now that we know we can easily split the `calibration` string into individual lines we "only" need to extract the two-digit numbers from them. Adding them is easy. 

## The actual problem

Looking within individual line, our problem can now be states as: given a string, extract first and last digit; join the two digits to form a two-digit number. 

Let's take one of the lines above and use it as a test case. 

```{julia}
#| output: false
cal_line = "a1b2c3d4e5f"
```

First a solution that is quite typical for students after their first MATLAB course. 

```{julia}
number = ""
@show number

for i in 1:length(cal_line)
    s = cal_line[i]
    if isdigit(s)
        number = number * s
        break
    end
end

@show number

for i in length(cal_line):-1:1
    s = cal_line[i]
    if isdigit(s)
        number = number * s
        break
    end
end

@show number

cal_value = parse(Int, number)
```

It works but is also suuuuper long. If you use e.g. VSCode, some of the code will be underlined with a squigly line. It is Julia's linter telling us that:

> Indexing with indices obtained from `length`, `size` etc is discouraged. Use `eachindex` or `axes` instead.

A linter is a tool that continously checks your code for possible errors and [anti-patterns](https://en.wikipedia.org/wiki/Anti-pattern). In this case it is pointing out that `for i in 1:length(cal_line)` is not cool. Let's try to include the proposed fix. 

Instead of creating a vector of indexes `1:length(cal_line)` we can just ask for it: `eachindex(cal_line)` and for the second case: `Iterators.reverse(eachindex(cal_line))`. This is advisable because arrays in Julia can have arbitrary indexes. Forget about the war between [0-based](https://en.wikipedia.org/wiki/Zero-based_numbering) and 1-based indexing in programming. Embrace [Star Wars movies order indexing](https://github.com/giordano/StarWarsArrays.jl). 

Notice that we did not use the `i` variable for anything other than indexing an element of the input string. We should take advante of the fact that we can just iterate over anything that is iterable. Any `String` or `Array` or similar data structure is. If a data structure can be described similar to: _a string is a collection of characters_ or _an array is a collection of numbers_ then it most likely is iterable. 

```{julia}
number = ""
@show number

for s in cal_line
    if isdigit(s)
        number = number * s
        break
    end
end

@show number

for s in reverse(cal_line)
    if isdigit(s)
        number = number * s
        break
    end
end

@show number

parse(Int, number)
```

The code is now a bit prettier but it still looks repetitive and quite verbose. The first loop looks for the first numeric character; the second loop looks for the last numeric character. Conceptually they do almost the same job. They iterate over a collection of characters until they find a digit. 

What if we first remove all the letters (non-digits) from the string? Then our search for digits will be much simpler. So how do we go from `"a1b2c3d4e5f"` to `"12345"`? 

## Interlude II: map filter reduce

The three functions: `map`, `filter` and `reduce` are the [workhorse](https://en.wikipedia.org/wiki/Functional_programming#Imperative_vs._functional_programming) of [functional programming](https://en.wikipedia.org/wiki/Functional_programming). 

- `map` applies a function element-wise to a collection
- `filter` yields a sub-collection based on some element criteria
- `reduce` accumulates an output based on subsequent elements

These three function can do a lot. 

```{julia}
function clip(x, x_min=-0.5, x_max=0.5)
    if x > x_max return x_max end
    if x < x_min return x_min end
    return x
end

@show clip(-1)
@show clip(0)
@show clip(0.7)

x = -π:0.01:π
y = sin.(x)
y_clipped = map(clip, y) # ← map does the heavy lifting here

using Plots
plot(x, y, label="sin(x)", xticks=(-π:π:π,["-π","0","π"]))
plot!(x, y_clipped, label="clip(sin(x))")
```

## Let the data flow

First lets use the newly acquired power to get rid of the letters in our line. Any function that returns a `Boolean` can be used inside a `filter`. 

```{julia}
cal_digits = filter(isdigit, cal_line)
```

Notice we do not give any input to the `isdigit` function. `filter` does that for us. It applies this function to every element of the collection and if the Answer is `True` the corresponding element gets to live a bit longer in the new, filtered collection. 

We can now extract the first and last numbers from this new string. 

```{julia}
first_cal_digit = first(cal_digits)
last_cal_digit = last(cal_digits)
cal_number = first_cal_digit * last_cal_digit
parse(Int, cal_number)
```

We have a pretty short code. More importanetly it is self documenting. Variable names clearly communicate what our intention was. I, however, don't like it. `first_cal_digit` variable name just repeats what `first(cal_digits)` communicates. Moreover its life is pretty short. We don't really need it. These short-lived variables can be ommited by nested function calls: 

```{julia}
first(filter(isdigit, cal_line))
```

However, nesting has a nasty habit of creating a sea of parentheses

```{julia}
#| eval: false
make(something(important(with(this(data)))))
```

This was typically remedied by [Rainbow Brackets](https://marketplace.visualstudio.com/items?itemName=2gua.rainbow-brackets). But there are better solutions. 

One is function compositions. Imagine glueing output of one function to the input of another function. This allows us to create new function without the need for intermediate variables.

```{julia}
#| eval: false
function_chain = make ∘ something ∘ important ∘ with ∘ this
function_chain(data)
```

or by piping the `data`

```{julia}
#| eval: false
data |> this |> with |> important |> something |> make
```

Notice how the operation order "reverses". The execution order does not change. With chained functions the last function in the chain would operate on the data first. Some languages allow for piping `<|` both ways `|>. Julia does not. 

```{julia}
filter(isdigit, cal_line) |> first
```

This is a neat way of piping data through a chain of functions

```{julia}
#| eval: false
output = data |> massage |> this |> into |> something |> different
```

We can also express this as a function chain:

```{julia}
#| eval: false
output = data |> massage |> this |> into |> something |> different
```

```{mermaid}
flowchart LR
  Input(data):::data --> A[massage] --> B[this] --> C[into] --> D[something] --> E[different] --> Result(output):::data
  classDef data fill:#C5F4E0
```

There is a small problem, however. There functions take one input and return one output. We need to extract two things: first and last digit. Then we need to sum the two numbers. 

```{mermaid}
flowchart LR
  Input(cal_line):::data --> Filter[filter numbers]
  Filter --> First[get first number] & Last[get last number] --> Sum[sum] --> Result(cal_number):::data
  classDef data fill:#C5F4E0
```

## Takeaways

### Look for patterns in the problem

Someone has done the boilerplate code for you
Map filter reduce

### Break the problem into smaller problems

Smaller problem = less things to keep in your head at a time
TDD
Parallel work
Modularity