[
  {
    "objectID": "electronics.html",
    "href": "electronics.html",
    "title": "Sheep observer",
    "section": "",
    "text": "Making LTSpice pretty\n\n\n\n\n\n\n\nSPICE\n\n\nLTspice\n\n\n\n\n\n\n\n\n\n\n\nJun 24, 2023\n\n\nSzymon Bęczkowski\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "programming.html",
    "href": "programming.html",
    "title": "Sheep observer",
    "section": "",
    "text": "I am not a programmer. I dabble in programming.\nStarted with Pascal and BASIC in the previous century. Learned basics of C at the universtity. Had a short affair with Ruby when Rails was popular. Chunky bacon. Tried Objective-C but gave up easily. Drew LabView because it connected to all the measurement gear around. Wrote some C++ for my beloved DSP processor. Did MATLAB for many years because of academic pressure, got good at it, dropped it for Julia. Licked some LISP but it tased of unclosed parentheses. Got my head blown by Haskell. Currently APL curious because it looks beautiful but not curious enough to actually do anything about it.\nI treat programming languages like bicycles. You can never have too many.\n\n\n\n\n\n\n\n\n  \n\n\n\n\nA short introduction to functional programming in Julia\n\n\n\n\n\n\n\nJulia\n\n\nfunctional programming\n\n\nAdvent of Code\n\n\n\n\nHow to structure the code using nothing but circles and pipes.\n\n\n\n\n\n\nDec 12, 2023\n\n\nSzymon Bęczkowski\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "electronics/LTSpice-color-theme/LTSpice-color-theme.html",
    "href": "electronics/LTSpice-color-theme/LTSpice-color-theme.html",
    "title": "Making LTSpice pretty",
    "section": "",
    "text": "You can change the default color palette of LTSpice. The default one is very depressing. I use a black and white theme with waveforms color scheme from MATLAB.\n\n\n\n\n\n\n\n\n\n\nColors can be changed using GUI or by modifying the values in the config file.\n\n\n\n\n\n\n\nOS\npath\n\n\n\n\nmacOS\n~/Library/Preferences/LTC.LTspice.plist\n\n\nWindows\n%USERPROFILE%\\AppData\\Roaming\\LTspiceXVII.ini\n\n\nLinux\n~/.wine/drive_c/users/$USER/Application\\ Data/LTspiceXVII.ini"
  },
  {
    "objectID": "electronics/LTSpice-color-theme/LTSpice-color-theme.html#color-theme",
    "href": "electronics/LTSpice-color-theme/LTSpice-color-theme.html#color-theme",
    "title": "Making LTSpice pretty",
    "section": "",
    "text": "You can change the default color palette of LTSpice. The default one is very depressing. I use a black and white theme with waveforms color scheme from MATLAB.\n\n\n\n\n\n\n\n\n\n\nColors can be changed using GUI or by modifying the values in the config file.\n\n\n\n\n\n\n\nOS\npath\n\n\n\n\nmacOS\n~/Library/Preferences/LTC.LTspice.plist\n\n\nWindows\n%USERPROFILE%\\AppData\\Roaming\\LTspiceXVII.ini\n\n\nLinux\n~/.wine/drive_c/users/$USER/Application\\ Data/LTspiceXVII.ini"
  },
  {
    "objectID": "electronics/LTSpice-color-theme/LTSpice-color-theme.html#macos-caveats",
    "href": "electronics/LTSpice-color-theme/LTSpice-color-theme.html#macos-caveats",
    "title": "Making LTSpice pretty",
    "section": "macOS caveats",
    "text": "macOS caveats\nDo not try to edit the macOS .plist file as it is just a pretty-printed version of a binary file. johan162 made a color theme manager script to simplify theme changes on macOS. The script comes with a few themes. You can add your own theme to the ~/.ltspice_themes/themes.ltt list and set that as default. This is what I use:\n[szymon]\nGridColor=9868950\nInActiveAxisColor=9868950\nWaveColor0=16777215\nWaveColor1=11513775\nWaveColor2=11826975\nWaveColor3=884479\nWaveColor4=2859051\nWaveColor5=2631381\nWaveColor6=12412564\nWaveColor7=4871819\nWaveColor8=12744675\nWaveColor9=8289918\nWaveColor10=2211260\nWaveColor11=13614615\nWaveColor12=128\nWaveColor13=44975\nSchematicColor0=0\nSchematicColor1=2631720\nSchematicColor2=0\nSchematicColor3=0\nSchematicColor4=12648447\nSchematicColor5=0\nSchematicColor6=0\nSchematicColor7=0\nSchematicColor8=9868950\nSchematicColor9=0\nSchematicColor10=11210240\nSchematicColor11=16777215\nSchematicColor12=16777215\nNetlistEditorColor0=0\nNetlistEditorColor1=32512\nNetlistEditorColor2=16711680\nNetlistEditorColor3=155\nNetlistEditorColor4=16777215"
  },
  {
    "objectID": "all.html",
    "href": "all.html",
    "title": "Sheep observer",
    "section": "",
    "text": "A short introduction to functional programming in Julia\n\n\n\n\n\n\n\nJulia\n\n\nfunctional programming\n\n\nAdvent of Code\n\n\n\n\nHow to structure the code using nothing but circles and pipes.\n\n\n\n\n\n\nDec 12, 2023\n\n\nSzymon Bęczkowski\n\n\n\n\n\n\n  \n\n\n\n\nMapping with LIDAR data\n\n\n\n\n\n\n\nimagery\n\n\nLIDAR\n\n\n\n\nLIDAR data can reveal features hidden under forest canopy. It is especially useful for discovering trails and other man-made structures not visible on standard imagery.\n\n\n\n\n\n\nJun 30, 2023\n\n\nSzymon Bęczkowski\n\n\n\n\n\n\n  \n\n\n\n\nMaking LTSpice pretty\n\n\n\n\n\n\n\nSPICE\n\n\nLTspice\n\n\n\n\n\n\n\n\n\n\n\nJun 24, 2023\n\n\nSzymon Bęczkowski\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "openstreetmap/mapping-with-LIDAR-data/mapping-with-LIDAR-data.html",
    "href": "openstreetmap/mapping-with-LIDAR-data/mapping-with-LIDAR-data.html",
    "title": "Mapping with LIDAR data",
    "section": "",
    "text": "Urban trees, especially big dense ones, are becoming a rare sight in our environment. They provide habitat for many species, offer shade in the summer, combat the heat island effect, reduce stormwater pollution, filter air, absorb noise and are beneficial for our mental health. Despite all these superb benefits I have one bone to pick with them—they block my view from above.\n\n\n\n\n\nThe area you see above is a natural=wood for OSM mapper. There are some quirks on how you map an area like this. OSM wiki mentions six different approaches. Irrespective of the approach taken, one question remains: what is under the trees?\nIf you are lucky, there may be a different map source where the imagery is taken in the winter months, with fewer leaves on the trees. If you are mapping an urban place, you may see GPS traces taken by joggers. That will give you an idea about path locations.\nEnter LIDAR. LIDAR generates a 3D representation of the scanned area using laser pulses. The first practical LIDAR systems date back to the 60s, but until recently, LIDAR was limited in applications. Recent advancements in data processing, have made its use more common.\nIt is now used, for example, to archive heritage sites so that they can be viewed by the future generations. They are also used in agriculture for crop monitoring.\nLIDAR became more widely known by the general public when it was used to discover artifacts of ancient civilisations. These artifacts were, until now, hidden under the canopy of the rainforest. LIDAR scanning revealed a network of settlements within the Amazon forest. Similar to Amazon surveyors, we can now use LIDAR data to reveal hidden objects under the canopy.\n\n\n\n\n\n\n\n\n\n\n\n\nAbove, you see two images of the same forest area, as above, but seen by the LIDAR system. The second image reveals a structure underneath the foliage. In this case, it is a Second World War era hospital bunker that is in the area of a past airport. It is not visible from the air. It is not visible from the road. I only stumbled upon it thanks to geocaching.\nBut how does LIDAR see under the canopy?"
  },
  {
    "objectID": "openstreetmap/mapping-with-LIDAR-data/mapping-with-LIDAR-data.html#foliage-sucks",
    "href": "openstreetmap/mapping-with-LIDAR-data/mapping-with-LIDAR-data.html#foliage-sucks",
    "title": "Mapping with LIDAR data",
    "section": "",
    "text": "Urban trees, especially big dense ones, are becoming a rare sight in our environment. They provide habitat for many species, offer shade in the summer, combat the heat island effect, reduce stormwater pollution, filter air, absorb noise and are beneficial for our mental health. Despite all these superb benefits I have one bone to pick with them—they block my view from above.\n\n\n\n\n\nThe area you see above is a natural=wood for OSM mapper. There are some quirks on how you map an area like this. OSM wiki mentions six different approaches. Irrespective of the approach taken, one question remains: what is under the trees?\nIf you are lucky, there may be a different map source where the imagery is taken in the winter months, with fewer leaves on the trees. If you are mapping an urban place, you may see GPS traces taken by joggers. That will give you an idea about path locations.\nEnter LIDAR. LIDAR generates a 3D representation of the scanned area using laser pulses. The first practical LIDAR systems date back to the 60s, but until recently, LIDAR was limited in applications. Recent advancements in data processing, have made its use more common.\nIt is now used, for example, to archive heritage sites so that they can be viewed by the future generations. They are also used in agriculture for crop monitoring.\nLIDAR became more widely known by the general public when it was used to discover artifacts of ancient civilisations. These artifacts were, until now, hidden under the canopy of the rainforest. LIDAR scanning revealed a network of settlements within the Amazon forest. Similar to Amazon surveyors, we can now use LIDAR data to reveal hidden objects under the canopy.\n\n\n\n\n\n\n\n\n\n\n\n\nAbove, you see two images of the same forest area, as above, but seen by the LIDAR system. The second image reveals a structure underneath the foliage. In this case, it is a Second World War era hospital bunker that is in the area of a past airport. It is not visible from the air. It is not visible from the road. I only stumbled upon it thanks to geocaching.\nBut how does LIDAR see under the canopy?"
  },
  {
    "objectID": "openstreetmap/mapping-with-LIDAR-data/mapping-with-LIDAR-data.html#how-lidar-works",
    "href": "openstreetmap/mapping-with-LIDAR-data/mapping-with-LIDAR-data.html#how-lidar-works",
    "title": "Mapping with LIDAR data",
    "section": "How LIDAR works",
    "text": "How LIDAR works\nA LIDAR detector is flown overhead a terrain and short laser pulses are emitted towards the ground. The system then measures the distance to the surface that the laser targeted. Knowing the position of the senor and laser pulse direction the LIDAR can calculate the position of the object hit by the laser pulse. A 3D point cloud is then slowly built while the laser scans the terrain.\nSometimes, the laser pulse will hit a leaf. Other times, it will accidentally find an opening between leaves and reach the ground. The resulting point cloud then consists of the points that hit the ground surface and points that hit random leaves. By filtering points that are as high and as low as possible, we can then create two images: one including the foliage and one containing only the ground and solid objects."
  },
  {
    "objectID": "openstreetmap/mapping-with-LIDAR-data/mapping-with-LIDAR-data.html#where-lidar-shines",
    "href": "openstreetmap/mapping-with-LIDAR-data/mapping-with-LIDAR-data.html#where-lidar-shines",
    "title": "Mapping with LIDAR data",
    "section": "Where LIDAR shines",
    "text": "Where LIDAR shines\nFor OSM mappers, LIDAR is especially useful for discovering and aligning paths in woody areas. The image below looks like a well-mapped nature area with many criss-crossing paths.\n\n\n\n\n\nFootpaths and bike tracks form long troughs on forest beds and are clearly visible on LIDAR imagery. Notice below how many paths are misaligned or just missing.\n\n\n\n\n\n\n\nOther geo features that are clearly visible on LIDAR images are water bodies, streams, embankments and ditches.\nNot all countries have LIDAR data available. I have used Denmark as an example of excelent coverage. The source for the maps used is Styrelsen for Dataforsyning og Infrastruktur (SDFE aerial imagery, SDFE surface shadow map (40 cm) and SDFE terrain shadow map (40 cm)).\nI hope you can use this technique to improve OpenStreetMap. If you are not an OSM editor, you can still use the LIDAR imagery to discover hidden gems in your surrounding area."
  },
  {
    "objectID": "openstreetmap.html",
    "href": "openstreetmap.html",
    "title": "Sheep observer",
    "section": "",
    "text": "Mapping with LIDAR data\n\n\n\n\n\n\n\nimagery\n\n\nLIDAR\n\n\n\n\nLIDAR data can reveal features hidden under forest canopy. It is especially useful for discovering trails and other man-made structures not visible on standard imagery.\n\n\n\n\n\n\nJun 30, 2023\n\n\nSzymon Bęczkowski\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Szymon Bęczkowski",
    "section": "",
    "text": "I am a researcher working on power electronics. I studied electrical engineering at Warsaw University of Technology. I did my PhD at Aalborg University, where I currently work as an associate professor. I mostly focus on power converters and power modules.\nAs a group, we research high power and high voltage power electronics, such as medium-voltage SiC technology. We also investigate digital techniques within the field of power electronics."
  },
  {
    "objectID": "index.html#who-am-i",
    "href": "index.html#who-am-i",
    "title": "Szymon Bęczkowski",
    "section": "",
    "text": "I am a researcher working on power electronics. I studied electrical engineering at Warsaw University of Technology. I did my PhD at Aalborg University, where I currently work as an associate professor. I mostly focus on power converters and power modules.\nAs a group, we research high power and high voltage power electronics, such as medium-voltage SiC technology. We also investigate digital techniques within the field of power electronics."
  },
  {
    "objectID": "index.html#what-do-i-like",
    "href": "index.html#what-do-i-like",
    "title": "Szymon Bęczkowski",
    "section": "What do I like?",
    "text": "What do I like?\nObserving sheep.\nIn my free time, I am contributing to OpenStreetMap.\nI am a strong proponent of modern open-source tools.\nJulia is my beloved programming language. I waited many years for LaTeX3 to arrive, finally materialising as Typst. This website is built with Quarto."
  },
  {
    "objectID": "programming/Julia-piping/piping.html",
    "href": "programming/Julia-piping/piping.html",
    "title": "A short introduction to functional programming in Julia",
    "section": "",
    "text": "Advent of code is a quaint site that posts one programming problem each day just before Christmas. Just so we can flex our programming muscle. More importanetly, we can eavsdrop on other people’s code. Looking at some of the solutions motivated me to write this tutorial.\nA lot of people start learning programming with C++ or MATLAB. This inevitably leads to a very verbose and error-prone code. In this tutorial, I aim to illustrate how modern programming practices and a good language can lead to elegant solutions and maintainable code."
  },
  {
    "objectID": "programming/Julia-piping/piping.html#the-problem",
    "href": "programming/Julia-piping/piping.html#the-problem",
    "title": "A short introduction to functional programming in Julia",
    "section": "The problem",
    "text": "The problem\nAdvent of code day one problem. The problem boils down to: given a string, extract first and last digits in each line; join the two digits to form a two-digit number and add all resulting numbers.\n\ncalibration = \"\"\"\n1abc2\npqr3stu8vwx\na1b2c3d4e5f\ntreb7uchet\n\"\"\""
  },
  {
    "objectID": "programming/Julia-piping/piping.html#interlude-i-splitting-hair-lines",
    "href": "programming/Julia-piping/piping.html#interlude-i-splitting-hair-lines",
    "title": "A short introduction to functional programming in Julia",
    "section": "Interlude I: splitting hair lines",
    "text": "Interlude I: splitting hair lines\nText manipulation is a fundamental challenge in programming, and nearly every programming language provides built-in primitives for this purpose.\nJulia’s function eachline is a conveninent tool for splitting a string into individual lines. However, attempting to pass our calibration variable into eachline we will result in an error. Fortunately, the docs provide guidance on this issue:\n\nTo iterate over each line of a String, eachline(IOBuffer(str)) can be used.\n\n\nfor cal_line in eachline(IOBuffer(calibration))\n    @show cal_line\nend\n\ncal_line = \"1abc2\"\ncal_line = \"pqr3stu8vwx\"\ncal_line = \"a1b2c3d4e5f\"\ncal_line = \"treb7uchet\"\n\n\nNow that we understand how to split the calibration string into individual lines, the next step is to “simpy” extract the two-digit numbers from each line. Adding them is straightforward."
  },
  {
    "objectID": "programming/Julia-piping/piping.html#the-actual-problem",
    "href": "programming/Julia-piping/piping.html#the-actual-problem",
    "title": "A short introduction to functional programming in Julia",
    "section": "The actual problem",
    "text": "The actual problem\nLooking within individual line, our problem can now be states as follows: given a string, extract first and last digits, and then join the two digits to form a two-digit number.\nLet’s take one of the lines above and use it as a test case.\n\ncal_line = \"a1b2c3d4e5f\"\n\nHere’s a solution that is quite typical for students after completing their first MATLAB course:\n\nnumber = \"\"\n@show number\n\nfor i in 1:length(cal_line)\n    s = cal_line[i]\n    if isdigit(s)\n        number = number * s\n        break\n    end\nend\n\n@show number\n\nfor i in length(cal_line):-1:1\n    s = cal_line[i]\n    if isdigit(s)\n        number = number * s\n        break\n    end\nend\n\n@show number\n\nparse(Int, number)\n\nnumber = \"\"\nnumber = \"1\"\nnumber = \"15\"\n\n\n15\n\n\nIt works but is also suuuuper long. If you are using an editor, like VSCode, you might notice some code underlined with a squiggly line. This is Julia’s linter telling us that:\n\nIndexing with indices obtained from length, size etc is discouraged. Use eachindex or axes instead.\n\nA linter is a tool that continously checks your code for possible errors and anti-patterns. In this case, it points out that for i in 1:length(cal_line) is not cool. Let’s implement the proposed fix.\nRather than creating a vector of indexes 1:length(cal_line), we can directly obtain using eachindex(cal_line) for the first case and Iterators.reverse(eachindex(cal_line)) for the second case. This approach is advisable because arrays in Julia can have arbitrary indexes. Forget about the war between 0-based and 1-based indexing styles. Embrace Star Wars movies order indexing.\nNotice that we did not use the i variable for anything other than indexing an element of the input string. We should take advantage of the fact that we can just iterate over anything that is iterable. Any String or Array or similar data structure is. If a data structure can be described similarly to: a string is a collection of characters or an array is a collection of numbers then it most likely is iterable.\n\nnumber = \"\"\n@show number\n\nfor s in cal_line\n    if isdigit(s)\n        number = number * s\n        break\n    end\nend\n\n@show number\n\nfor s in reverse(cal_line)\n    if isdigit(s)\n        number = number * s\n        break\n    end\nend\n\n@show number\n\nparse(Int, number)\n\nnumber = \"\"\nnumber = \"1\"\nnumber = \"15\"\n\n\n15\n\n\nThe code is now a bit prettier but it still appears repetitive and somewhat verbose. The first loop seeks the first numeric character, while the second loop seeks the last numeric character. In essence, they perform nearly identical tasks. They iterate over a collection of characters until they encounter a digit.\nWhat if we first remove all the letters (non-digits) from the string? Then our search for digits will be much simpler. So, how do we go from \"a1b2c3d4e5f\" to \"12345\"?"
  },
  {
    "objectID": "programming/Julia-piping/piping.html#interlude-ii-map-filter-reduce",
    "href": "programming/Julia-piping/piping.html#interlude-ii-map-filter-reduce",
    "title": "A short introduction to functional programming in Julia",
    "section": "Interlude II: map filter reduce",
    "text": "Interlude II: map filter reduce\nThe three functions–map, filter and reduce–are the workhorses of functional programming.\n\nmap applies a function element-wise to a collection\nfilter yields a sub-collection based on specified criteria\nreduce accumulates an output based on subsequent elements\n\nThese three functions are powerful tools in functional programming paradigm and can be employed for a wide range of tasks.\n\nfunction clip(x, x_min=-0.5, x_max=0.5)\n    if x &gt; x_max return x_max end\n    if x &lt; x_min return x_min end\n    return x\nend\n\n@show clip(-1)\n@show clip(0)\n@show clip(0.7)\n\nx = -π:0.01:π\ny = sin.(x)\ny_clipped = map(clip, y) # map does the heavy lifting here\n\nusing Plots\nplot(x, y, label=\"sin(x)\", xticks=(-π:π:π,[\"-π\",\"0\",\"π\"]))\nplot!(x, y_clipped, label=\"clipped sin(x)\")\n\nclip(-1) = -0.5\nclip(0) = 0\nclip(0.7) = 0.5"
  },
  {
    "objectID": "programming/Julia-piping/piping.html#let-the-data-flow",
    "href": "programming/Julia-piping/piping.html#let-the-data-flow",
    "title": "A short introduction to functional programming in Julia",
    "section": "Let the data flow",
    "text": "Let the data flow\nFirst lets use the newly acquired powers to get rid of the letters in our line. Any function, that returns a Boolean, can be used inside a filter.\n\ncal_digits = filter(isdigit, cal_line)\n\n\"12345\"\n\n\nNotice we do don’t explicitly provide any input to the isdigit function, instead filter does it for us. It applies the isdigit function to every element of the collection, and if the result is True, the corresponding element gets to live a bit longer in the new, filtered collection.\nNow, we can proceed to extract the first and last digits from the refined string.\n\nfirst_cal_digit = first(cal_digits)\nlast_cal_digit = last(cal_digits)\ncal_number = first_cal_digit * last_cal_digit\nparse(Int, cal_number)\n\n15\n\n\nWe’ve achieved a pretty concise code. More importanetly, it is self-documenting as variable names clearly convey our intentions. I, however, don’t like it. first_cal_digit variable name duplicates what first(cal_digits) communicates. Furthermore, its lifespan is pretty short so we don’t really need it. These short-lived variables can be ommited by using nested function calls:\n\nfirst(filter(isdigit, cal_line))\n\n'1': ASCII/Unicode U+0031 (category Nd: Number, decimal digit)\n\n\nHowever, nesting has a nasty habit of creating a sea of parentheses\n\nmake(something(important(with(this(data)))))\n\nThis was typically remedied by tools like Rainbow Brackets. However, there are more elegant solutions.\nOne such approach is function composition. Picture glueing the output of one function to the input of another. This enables us to construct new function without the need for intermediate variables.\n\nfunction_chain = make ∘ something ∘ important ∘ with ∘ this\nfunction_chain(data)\n\nThe ∘ operator composes (glues) functions together. No intermediate variables necessary.\nSimilar solution can also be achieved by piping the data with a |&gt; (pipe) operator.\n\ndata |&gt; this |&gt; with |&gt; important |&gt; something |&gt; make\n\nNotice how the flow of data changes direction. The input data, on the left, is piped through successive functions. It’s important to emphasize that the execution order remains unchanged. With composed functions, the last function in the chain would operate on the data first.\nSome languages allow for piping &lt;| both ways |&gt;. Julia does not. This can lead to some confusing code if |&gt; and ∘ are used together.\n\nπ |&gt; round ∘ sin\n\n0.0\n\n\nπ is first applied to sin and the result is then rounded.\nWe can use piping to find the first digit in our filtered string:\n\nfilter(isdigit, cal_line) |&gt; first\n\n'1': ASCII/Unicode U+0031 (category Nd: Number, decimal digit)\n\n\nAs you can see, piping is a neat way of pushing data through a chain of operations.\n\noutput = data |&gt; massage |&gt; this |&gt; into |&gt; something |&gt; different\n\n\n\n\n\nflowchart LR\n  Input(data):::data --&gt; A[massage] --&gt; B[this] --&gt; C[into] --&gt; D[something] --&gt; E[different] --&gt; Result(output):::data\n  classDef data fill:#C5F4E0\n\n\n\n\n\nThere is, however, a small problem. These functions take one input and return one output. Yet, our task involves extracting two things: the first and last digits. Subsequently, we need to sum these two numbers.\n\n\n\n\nflowchart LR\n  Input(cal_line):::data --&gt; Filter[filter numbers]\n  Filter --&gt; First[get first number] & Last[get last number] --&gt; Join[join] --&gt; Result(cal_number):::data\n  classDef data fill:#C5F4E0\n\n\n\n\n\nWe can massage our flow diagram, using Julia’s broadcasting mechanism, until we get a nice straight diagram:\n\n\n\n\nflowchart LR\n  Input(cal_line):::data --&gt; Filter[filter numbers]\n  Filter -.-&gt; Numbers[[get first and last numbers]] -.-&gt; Join[join] --&gt; Result(cal_number):::data\n  classDef data fill:#C5F4E0\n\n\n\n\n\n\nMassaging the chain\n\nfilter(isdigit, cal_line) .|&gt; (first, last)\n\n('1', '5')\n\n\nTwo crucial things happen here. First, (first, last) is a tuple (collection) of functions.\nJulia offers many ways of grouping things into a some form of collection: tuples, named tuples, arrays, dictionaries, structs, …. You can thing of tuples as a versatile container that holds multiple things without much boilerplate. They prove especially usefull when joining things for a moment, just as we need here.\nThe dot represents a broadcast operator. .|&gt; is a way of piping the data into multiple things at once, broadcasting data into individual inputs.\nIt functions similarly as cos.([π,π]), where two pies are shoved into a cosine even though the cosine function can only handle one pie at a time.\nNow we do have our first and last digits captured, but they still are in a character form. We need to convert them to numbers. As you may observe, the output of the previous operation is ('1', '5') This is a tuple of characters. A join function can create a string out of that.\n\nfilter(isdigit, cal_line) .|&gt; (first, last) |&gt; join\n\n\"15\"\n\n\nThe resulting string should be reinterpreted as a number. The parse function can do that for us but it requires two inputs: what to parse and how to parse it. To incorporate it into our streamlined code flow, we must embed one of the inputs.\n\nparseint(number) = parse(Int, number) # parseint() function has one input and one output\nfilter(isdigit, cal_line) .|&gt; (first, last) |&gt; join |&gt; parseint\n\n15"
  },
  {
    "objectID": "programming/Julia-piping/piping.html#interlude-iii-function-that-must-not-be-named",
    "href": "programming/Julia-piping/piping.html#interlude-iii-function-that-must-not-be-named",
    "title": "A short introduction to functional programming in Julia",
    "section": "Interlude III: Function-That-Must-Not-Be-Named",
    "text": "Interlude III: Function-That-Must-Not-Be-Named\nAs with variables, we can get rid of naming this short lived function by using an anonymous function. An anonymous function is a function without a name. Consider this function:\n\ndouble(x) = 2x\n\ndouble (generic function with 1 method)\n\n\nIt doubles whatever we feed to it. Now, let’s create an anonymous version of this function:\n\nx -&gt; 2x\n\n#13 (generic function with 1 method)\n\n\nJulia made it for us. It is function #13. Where is it then? How do we call it?\nFunction #13 is indeed quite unlucky. We did not catch it in time1 and it went to the void. Confusingly, we can name an anonymous function.1 A Pokémon function?\n\ntwofold = x -&gt; 2x\ntwofold(5)\n\n10\n\n\nMost common use of these anonymous functions is existence in a chain of functions or being passed to another function.\n\nmap(x-&gt;2x, [1,2,3]) # x-&gt;2x is an anonymous function that is passed to a map function\n\n3-element Vector{Int64}:\n 2\n 4\n 6\n\n\nWe will leverage this technique to parse a string into an integer. Now, the line parsing is complete.\n\nfilter(isdigit, cal_line) .|&gt; (first, last) |&gt; join |&gt; n -&gt; parse(Int, n)\n\n15"
  },
  {
    "objectID": "programming/Julia-piping/piping.html#answer-to-the-problem",
    "href": "programming/Julia-piping/piping.html#answer-to-the-problem",
    "title": "A short introduction to functional programming in Julia",
    "section": "Answer to the problem",
    "text": "Answer to the problem\nWe can now assemble all the pieces to solve the Advent of Code day 1 problem. We take the line parser we just wrote and wrap it in a function so we can parse any line we throw at it. Then, for each line in our calibration string, extract a calibration value. The sum of all calibration values is our answer.\n\ncal_value(line) = filter(isdigit, line) .|&gt; (first, last) |&gt; join |&gt; n -&gt; parse(Int, n)\nIOBuffer(calibration) |&gt; eachline .|&gt; cal_value |&gt; sum\n\n142\n\n\nThe answer to the problem is 142."
  },
  {
    "objectID": "programming/Julia-piping/piping.html#takeaways",
    "href": "programming/Julia-piping/piping.html#takeaways",
    "title": "A short introduction to functional programming in Julia",
    "section": "Takeaways",
    "text": "Takeaways\nTry to describe the solution algorithm in a sentence. Don’t focus on implementation just yet. Each verb in your description is a good candidate for a function. Each function can be thought as a sub-problem.\nBreaking down large problems into smaller, well-defined sub-problems not only makes makes the code more manageable but also enhances readability and maintainability. Strive to solve these isolated problems as pure functions. This kind of code organisation also works really well with test-driven development (TDD).\nThe smaller the problem the less code you need to write to solve it. Long and complex code can be challenging to navigate and reason about. Try keeping related code on one monitor screen2 for better comprehension, easier debugging and more efficient development.2 Rotating the monitor helps.\nAvoid iterating over data with a for loop unless you really have to. It is a short way to off-by-one and out-of-bounds errors. You will also be tempted to change variables inside the for loop and to create loops inside loops. Good luck debugging that."
  }
]